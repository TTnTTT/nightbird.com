---
title: 数据库基础
date: 2020-10-13 09:21:24
index_img: /img/blog_img.jpg
categories:
- [基础,数据库]
tags: [数据库,MySQL,Oracle,非关系数据库]
---

## 存储过程

### 概念及语法

存储过程是**为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行**。<u>存储过程就是具有名字的一段代码，用来完成一个特定的功能。</u>

> MySQL 5.0开始支持存储过程，这样即可以大大提高数据库的处理速度，同时也可以提高数据库编程的灵活性。

`CREATEPROCEDURE 存储过程名([[IN |OUT |INOUT ] 参数名 数据类形...])`

**三种参数类型：**

- IN 输入参数：表示调用者向过程传入值（传入值可以是字面量或变量）
- OUT 输出参数：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）
- INOUT 输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）

> 注意：输入值使用in参数。返回值使用out参数。inout参数就尽量的少用。

**变量：**

```mysql
DECLARE  variable_name [,variable_name...] datatype（MySQL数据类型）[DEFAULT value];#声明变量
```

```mysql
SET 变量名 = 表达式值 [,variable_name = expression ...] # 设置变量值
```

### 优点：

(1).增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。

(2).标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。

(3).较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。

(4).减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。

(5).作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。





###  存储过程和函数的区别：

1）一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。存储过程，功能强大，可以执行包括修改表等一系列数据库操作；用户定义函数不能用于执行一组修改全局数据库状态的操作。

2）对于存储过程来说可以返回参数，如记录集，而函数只能返回值或者表对象。函数只能返回一个变量；而存储过程可以返回多个。存储过程的参数可以有IN,OUT,INOUT三种类型，而函数只能有IN类~~存储过程声明时不需要返回类型，而函数声明时需要描述返回类型，且函数体中必须包含一个有效的RETURN语句。

3）存储过程，可以使用非确定函数，不允许在用户定义函数主体中内置非确定函数。

4）存储过程一般是作为一个独立的部分来执行（ EXECUTE 语句执行），而函数可以作为查询语句的一个部分来调用（SELECT调用），由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。 SQL语句中不可用存储过程，而可以使用函数。  

## ACID

* 原子性（Atomicity）
原子性是指事务是一个**不可分割**的工作单位，事务中的操作要么都发生，要么都不发生。
* 一致性（Consistency）
事务前后数据的完整性必须保持一致。
* 隔离性（Isolation）
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
* 持久性（Durability）
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。
## 事务隔离级别

``` set transaction isolation level #设置事务隔离级别 ```
``` select @@tx_isolation	#查询当前事务隔离级别```
**脏读：** 指一个事务读取了另外一个事务未提交的数据。
**不可重复读：** **<u>在一个事务内</u>**读取表中的某一行数据，**<u>多次读取</u>**结果不同。（这个不一定是错误，只是某些场合不对）
**幻读：** 是指在一个事务内读取到了**别的事务插入**的数据，导致前后读取不一致。（一般是行影响，多了一行）

> 例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的<u>全部数据行</u>。同时，第二个事务也修改这个表中的数据，这种修改是向表中<u>插入一行新数据</u>。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

| 设置                          | 描述                                                         |
| :---------------------------- | ------------------------------------------------------------ |
| Serializable                  | 可避免脏读、不可重复读、虚读情况的发生。（串行化，<u>在每个读的数据行上加上共享锁，即读锁</u>，其他事务可读不可写） |
| Repeatable read（MySQL默认）  | 可避免脏读、不可重复读情况的发生，但存在幻读。（可重复读）   |
| Read committed （Oracle默认） | 可避免脏读情况发生（读已提交，不可重复读）<u>使用MVCC解决不可重复读问题</u>。 |
| Read uncommitted              | 最低级别，以上情况均无法保证。(读未提交)                     |

## MySQL 语句执行过程

MySQL 主要分为 **Server 层**和**引擎层**，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。

![](source/img/images/mysql组件.webp)

## MySQL语句执行顺序
(1)from 
(3) join 
(2) on 
(4) where （因为聚集函数还在后面，where中不能使用聚集函数）
(5)group by(**开始使用select中的别名，后面的语句中都可以使用**)
(6) avg,sum.... 
(7)having 
(8) select 
(9) distinct 
(10) order by 

## 数据库左右连接
左连接会把**左表**(左表 left)的内容全部查出来再拼接**右表**(join 右表)，右连接相反的。

## Mysql 性能优化

- 1、建表的时候选择正确的存储引擎，如mysql中：**增查**操作远远**多于** **改删**，经常需要使用count时（MyISAM每一条记录有记录行数信息），选用MyISIM比较合理。频繁修改以及涉及到安全性较高的表选用`InnoDB`.

- 2.建表遵循三范式（讲三范式）

- 3.合理建索引（重复率低的适合建索引）

- 4.避免索引失效：

- 当只要一行数据时使用 limit 1；

  使用**join** 操作代替子查询，但join不要超过5个；

  在使用关联查询时，多使用小表驱动大表（因为小表数据量小）。

- 用 not exists 代替 not in



## Count 聚集函数的使用：

- 如果在开发中确实需要用到count()聚合，那么优先考虑count(*)，因为mysql数据库本身对于count(*)做了特别的优化处理。

- 有主键或联合主键的情况下，count(*)略比count(1)快一些。

- 没有主键的情况下count(1)比count(*)快一些。

- 如果表只有一个字段，则count(*)是最快的。

- 使用count()聚合函数后，最好不要跟where age = 1；这样的条件，会导致不走索引，降低查询效率。除非该字段已经建立了索引。使用count()聚合函数后，若有where条件，且where条件的字段未建立索引，则查询不会走索引，直接扫描了全表。

- count(字段),非主键字段，这样的使用方式最好不要出现。因为它不会走索引.

## 三范式

- 1NF：强调的是**列的原子性**，即列不能够再分成其他几列。 
- 2NF：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 
- 3NF：任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖]。

## 三种删除语句(drop， delete,  truncate)

- delete和truncate只删除表的数据不删除表的结构
- 速度 drop > truncate > delete
- 想删除部分数据时， delete 删除时要带上where语句
- 保留表而想删除所有的数据时用**truncate**

## 在select语句后面有sum(xx)时,记录会变为一条(很神奇!)

# 索引

## 避免索引失效

### 1.注意数据类型的隐式转换

如`select name,phone from customer where id = '111'（id本来是int型）;`'111'发生了隐式转换，id上的索引失效。

### 2.避免使用双%号的查询条件

如：`a like '%123%'`索引失效，（如果无前置%,只有后置%，是可以用到列上的索引的）

### 3. 注意联合索引的最左原则

`where a>1 and b=2 and c=9`有 a,b,c 列的联合索引，在查询条件中有 **a 列的范围查询**，则在 b,c 列上的索引将不会被用到。

### 4.少使用not in

使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。

### 5. 禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询

**原因：**

- 消耗更多的 CPU 和 IO 以网络带宽资源

- 无法使用覆盖索引

- 可减少表结构变更带来的影响

## MySQL索引类型(按)

*  ==普通索引== ：最基本的索引，它没有任何限制，用于加速查询。
``` CREATE INDEX index_mytable_name ON mytable(name);```
* ==唯一索引==：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
``` CREATE UNIQUE INDEX index_mytable_name ON mytable(name);```
* ==主键索引==：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。
```  CREATE TABLE mytable ( `id` int(11) NOT NULL AUTO_INCREMENT , `name` VARCHAR(32) , PRIMARY KEY (`id`) );```
* ==组合索引==：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循**最左前缀集合**。
``` CREATE INDEX index_mytable_id_name ON mytable(id,name);```
* ==全文索引==：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。
fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。
fulltext索引配合match against操作使用，而不是一般的where语句加like。
它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。
**缺点**：虽然索引可以增加查询数据，但对于更新、创建或者删除的时候，需要去维护索引，导致性能会受影响，因此，索引也不能建立太多。

### 主键索引与非主键索引

- 1.主键索引索引着数据，然而普通索引索引着主键ID值(这是在innodb中，但是如果是myisam中，主键索引和普通索引是没有区别的都是直接索引着数据)
- 2.当你查询用的是where id=x 时，那只需要扫描一遍主键索引，然后拿到相应数据，但是如果是查询的普通索引的话，那么会先扫描一次普通索引，拿到主键值，然后再去扫主键索引，拿到所需要的数据，这个过程叫做**回表**

## 索引存储结构

常见的MySQL主要有两种结构：**Hash索引和B+ Tree索引**，我们使用的是InnoDB引擎，默认的是B+树。

### 什么是B+树？

B+与B-树的区别:
* (1) 非叶子节点只存储键值信息
*    (2) 所有叶子节点之间都有链指针
> 这样做是为了提高区间效率，例如查询key为从18到49的所有数据记录，当找到18后，只要顺着节点和指针顺序遍历就可以以此向访问到所有数据节点，极大提高了区间查询效率。
>
>  *   (3) 数据记录都存放在叶子节点中

B-Tree模型：
![](source/img/images/b-Tree.png)

B+Tree模型:
![](source/img/images/B+Tree.png)
B+Tree优点:

* 大大减少磁盘I/O读取
数据库系统的设计者巧妙利用了**磁盘预读原理**，将一个节点的大小设为等于一个页，这样每个节点需要一次I/O就可以完全载入。

## 聚集索引和非聚集索引

聚集索引:

**数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。**MySQL的InnoDB使用的即为聚簇索引，默认使用主键作为索引，所以必须有主键。

![](source/img/images/聚集索引.JPG)

非聚集索引:

**该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。**MySQL的MyISAM即为非聚簇索引。

查询**非聚集索引覆盖以外的列**就会变成**聚集索引的全索引扫描（index scan）**查询来避免二次查询，**解决方案：**

> 建立两列以上的索引（复合索引），即可查询复合索引里的列的数据而不需要进行回表二次查询，如index(col1, col2)，这里需要注意最左匹配原则。

![](source/img/images/聚非集索引.JPG)



# 并发

## 数据库并发场景：

- **读-读**：不存在任何问题，也不需要并发控制

- **读-写**：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读

- **写-写**：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失



## MVCC (多版本控制)



### 是什么？

是一种用来解决**读-写**冲突的无锁并发控制.

> MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读, 维持一个数据的多个版本，使得读写操作没有冲突.

区分下现在有个新前后端分离的叫`MVVM`.

实现了只有**写数据&写数据**之间相互阻塞.只在`Read Committed `和 `Repeatable Read`两个隔离级别下工作。
[参考文章](https://blog.csdn.net/Waves___/article/details/105295060)

实现方法: `隐藏字段`+`ReadView`+`Undo log`。

### 1.三个隐藏字段
* DB_TRX_ID(6字节):表示最近一次对本记录行作修改（insert | update）的事务ID
* DB_ROLL_PTR(7字节):回滚指针，指向当前记录行的undo log信息
* DB_ROW_ID(6字节)：随着新行插入而单调递增的行ID

### 2.ReadView结构
相当于快照
包含四个字段:
① low_limit_id：目前出现过的最大的事务ID+1，即下一个将被分配的事务ID。
② up_limit_id：活跃事务列表trx_ids中最小的事务ID，如果trx_ids为空，则up_limit_id 为 low_limit_id。
③ trx_ids：Read View创建时其他未提交的活跃事务ID列表。
④ creator_trx_id：当前创建事务的ID，是一个递增的编号

### 3.Undo log
Undo log中存储的是老版本数据，当一个事务需要读取记录行时，如果当前记录行不可见，可以顺着undo log链找到满足其可见性条件的记录行版本。
> 不同事务或者相同事务的对同一记录行的修改，会使该记录行的undo log成为一条链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录

记录修改流程如下:
![](source/img/images/20200701205716343.png)
（1）现在事务A（事务ID为2）对该记录的Honor做出了修改，将Honor改为"fmvp"：

 >   ​    ①事务A先对该行加排它锁
​    ②然后把该行数据拷贝到undo log中，作为旧版本
​    ③拷贝完毕后，修改该行的Honor为"fmvp"，并且修改DB_TRX_ID为2（事务A的ID）, 回滚指针指向拷贝到undo log的旧版本。（然后还会将修改后的最新数据写入redo log）
​    ④事务提交，释放排他锁

![](source/img/images/20200701210046670.png)

## MVCC常见使用方式

- MVCC + 悲观锁
   MVCC解决读写冲突，悲观锁解决写写冲突

- MVCC + 乐观锁
   MVCC解决读写冲突，乐观锁解决写写冲突
   这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题

## 当前读和快照读
**快照读(snapshot read)**：普通的 select 语句(不会加锁,**不包括** select ... lock in share mode, select ... for update)，

> 快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

**当前读(current read) :** select ... lock in share mode【共享锁】，select ... for update，insert，update，delete【排他锁】 语句

> 这些语句**会对记录加锁**,读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。，获取的是数据库中的**最新数据.**



> **因为当前读的存在所以MVCC也可能会存在*部分幻读***

 ## MySQL的锁
### 一.表锁
- MyISAM存储引擎只支持表锁
- 分为 读锁/写锁 `lock table read/write` **读锁不互斥,写锁互斥**

###  二.行锁（Record Lock）
#### 锁直接加在索引记录上面，锁住的是key。
* 只有Innodb存储引擎才支持行锁,行锁是针对事务来的
* 只有在**需要的时候**才会加上,等事务结束后才释放锁,两阶段锁协议
* 分为共享锁和排他锁
  - **共享锁:** `select xxxx LOCK IN SHARE MODE` 
  多个事务只能读数据不能改数据.   
  加上共享锁后在事务结束之前其他事务只能再加共享锁.

  - **排他锁**: `select xxxx FOR UPDATE` 
  其他事务不能修改数据也不能再在其上加其他的锁.*可以普通查询.*
== MySQL执行增删改语句默认会加上排他锁 ==

 ##### 产生死锁
 - 原因:肯定得复习下死锁产生的四个条件(互斥，占有且等待，不可抢占，循环等待),翻译过来就是一个事务锁住了资源而长期未提交,其他事务要用资源时,产生死锁.
 - 解决办法
   * 设置MySQL锁等待超时 `innodb_lock_wait_timeout=50 `，*也可以不要事务autocommit=on*
   * 设置死锁机制 `innodb_deadlock_detect=on
   * 手动:`show processlist;` #查看正在执行的sql 然后kill掉

### 三.间隙锁（Gap Lock）
##### 锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而已的。

### 四.Next-Key Lock 
#### 默认情况下innodb以这种方式加锁,行锁和间隙锁组合起来就叫Next-Key Lock
- 当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。
- 防止其他事务的插入操作，以此防止幻读的发生。

**innodb的锁规则:**
- 如果查询时没有走索引,会进行全表扫描,所以行锁会升级会表锁.
- 如果更新条件为索引字段，但是并非唯一索引（包括主键索引）,会使用Next-Key Lock.
- 如果更新条件为唯一索引，则使用Record Lock（记录锁).
- 使用`in`语句加锁时会按从小到大顺序加锁.

### MySQl日志
- 1：redo log(重做日志)
　确保事务的持久性,redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。

- 2：undo log(回滚日志)
  - 保存了事务发生之前的数据的一个版本，可以用于回滚.
  - 提供多版本并发控制下的非锁定读（MVCC）.

- 3：binlog(二进制日志 )
  - 用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。
  - 用于数据库的基于时间点的还原。

## MySQL自增id用完怎么办?
- 能避免的时候就使用bigint作为主键id.
- (innodb中)**没设置**主键时使用隐藏字段`DB_ROW_ID`
- 使用thread_id(`SHOW PROCESSLIST`结果的第一列),每建立一个连接id加1,但是不会重复.

## 区分join操作的驱动表
- 区分:`left join`时左表为驱动表**（主表）**,右表为被驱动表.
right join时相反,inner join时小表为驱动表
- **优化方案:**
  * 在sql优化中，永远是以小表驱动大表.
  * 给被驱动表建立索引才会有效.

## MySQL 从一个表中查数据并插入另一个表实现方法:
* 如果两张表（导出表和目标表）的字段一致，并且希望插入全部数据，可以用这种方法：
```INSERT INTO  目标表  SELECT  * FROM  来源表 ;```
* 如果只希望导入指定字段，可以用这种方法(注意两张表字段类型一致)：
```INSERT INTO  目标表 (字段1, 字段2, ...)  SELECT   字段1, 字段2, ...   FROM  来源表 ;``` 


## 大表优化
#### 1. 限定数据的范围

务必禁止不带任何限制数据范围条件的查询语句。

#### 2. 读/写分离

经典的数据库拆分方案，主库负责写，从库负责读。

#### 3.垂直分区

**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 

#### 4. 水平分区

把一张表的数据拆分为多张表来存。

**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。==水平拆分最好分库== ** 。

## 表的列 & 行 方向的关联

### 行方向

两个表的行方向的关联，主要是指表与表之间并集、交集等集合运算。

**1.表与表之间的合并**。主要使用`union`这个运算符，其使用方法如下：

`select 列名 from 表1`

`union`

`select 列名 from 表2`

**在书写时，需要注意以下几点：**

- A.两个select语句中的列数必须相同，而且对应列的数据类型必须一致。

- B.order by子句只能放在最后使用。

- C.union给出的结果是去除重复行的。也就是说表1和表2没有重复的行，如果想要保留重复行，可以将union换成union all。

**2.表和表之间的交集**，可以使用`intersect`这个运算符。其语法及注意事项与union完全一样：

`select 列名 from 表1`

`intersect`

`select 列名 from 表2`

同样，如果想保留重复行，将intersect换成intersect all即可。结果返回两表之间的公共部分。

### 列方向

- inner join——内连接

  只会返回两表的共有数据。

- outer join——外连接

   * 左外连接 `left join`

      **left 前面**的表作为主表，会查出主表的所有数据。

   * 右外连接

     **right 后面**的表为主表，会查出主表的所有数据。

## 什么是池化？

数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。**在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中**。 连接池还减少了用户必须等待建立与数据库的连接的时间

## 分库分表后怎么控制全局 id

生成全局 id 有下面这几种方式：

- **UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。
- **数据库自增 id** : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
- **利用 redis 生成 id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。
- **Twitter的snowflake算法** ：Github 地址：<https://github.com/twitter-archive/snowflake。>