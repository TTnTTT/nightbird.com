---
title: Java底层相关
date: 2020-6-12 12:38:51
updated: 2020-10-1
index_img: /img/blog_img.jpg
categories:
- [基础,Java]
tags: [Java,底层原理]
---

## JVM内存结构：

### Runtime Data Area(运行时数据区):
**jdk1.7前的:**
{% asset_img /img/bg.png This is an example image %}

![](/img/images/Java运行数据区.png)

**jdk1.8之后**:
![](/img/images/2019-3Java运行时数据区域JDK1.8.png)
==注:1.8之后的元数据区 \= 1.8之前的方法区==
只有**堆区**和**元数据区**的数据是**线程共享**的.
只有程序计数器不会发生OOM.


#### **1.程序计数器**
* 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
* 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

#### **2.Java虚拟机栈**
我们常说的**栈区**就是现在说的虚拟机栈，或者说是虚拟机栈中**局部变量表**部分。
存放:（boolean、byte、char、short、int、float、long、double）、对象引用

>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息
对于函数:每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后(return语句/抛出异常)，都会有一个栈帧被弹出。

####　**3.本地方法栈**

#### 4.元空间

又叫静态区，存放所有的**①类（class），②静态变量（static变量），③静态方法，④常量和⑤成员方法**。

####　**5.堆**
**几乎所有**^jdk1.7就开始未逃逸的对象可以直接在栈中分配内存^的对象实例以及数组都在这里分配内存。
**jdk1.8之后堆的分割:**
![](/img/images/JVM堆内存结构-jdk8.png)
**==永久代被移除==,被元空间代替,使用的直接内存.**

年龄晋升源码:
```
Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，
当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中
更小的一个值，作为新的晋升年龄阈值.
uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {
    //survivor_capacity是survivor空间的大小
  size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);
  size_t total = 0;
  uint age = 1;
  while (age < table_size) {
    total += sizes[age];//sizes数组是每个年龄段对象大小
    if (total > desired_survivor_size) break;
    age++;
  }
  uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;
    ...
}
```

###	几种垃圾回收算法
* 标记-清除算法（Mark-Sweep）
> 适用: 对象存活率高的,老年代
缺点: 效率低(扫描两次)、空间会产生大量碎片、有大对象进来时就存不了了

* 复制算法（Copying）
> 空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。
适用: 存活对象比较少,年轻代
缺点: 需要移动对象,需要空间
**可以升级为按8:1:1划分为一块Eden和两块Survivor**
![](/img/images/分代.png)

* 标记-整理算法（Mark-Compart）
> 把小垃圾碎片挪动到一起、标记–》移动–》检查–》再标记–》清除
G1就是采用的这种算法.

**==分代回收==**
不同生命周期的对象可放在不同的区域中，针对不同区域使用不同的回收算法.
大对象会直接存放到老年代,小对象经过多轮筛选还是存活的对象也会进入老年代.

  - 年轻代
  - 老年代

**==FULL GC==**
^YGC时间过长^ 和 ^FGC过于频繁^ 都可能会造成OOM.
产生原因:

- 老年代空间不足,持久代空间不足直接触发FGC
  * 程序BUG导致动态生成了很多新类，使得 Metaspace(元空间)不断被占用，先引发FGC，最后导致OOM.
  * 内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.
  * 大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。
调优时应尽量做到让对象在Minor GC,YGC阶段被回收.
- System.gc()或Runtime.gc()**建议**系统进行FGC。
- JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。
  * 设置堆的最大最小值:-xms -xmx
  * 调整老年代和年轻代比例 -XX:newSize
  * >-Xms4g -Xmx4g -Xmn2g -Xss1024K -XX:ParallelGCThreads=5 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=80
可以看到堆内存为4G，新生代为2G，老年代也为2G，新生代采用ParNew收集器，老年代采用并发标记清除的CMS收集器，当老年代的内存占用率达到80%时会进行FGC。

> 不管YGC还是FGC，都会造成一定程度的程序卡顿（即Stop The World问题：GC线程开始工作，其他工作线程被挂起），即使采用ParNew、CMS或者G1这些更先进的垃圾回收算法，也只是在减少卡顿时间，而并不能完全消除卡顿。


###	判断对象存活的算法
**1、 引用计数算法** ==存在循环引用问题==

**2、 可达性分析算法**
虚拟机栈中引用的对象,方法区中静态属性/常量引用的对象,本地方法栈中的native方法引用的对象,活跃线程引用的对象.

### 垃圾回收实例
![](/img/images/常见GC回收器.png)
图片上面一排是新生代区的垃圾回收器 —MGC（Minor GC），下面一排是老年代的垃圾回收器 —FGC（Major GC / Full GC）。==G1分区不分代.==

**G1**
分区不分代,使用的标记整理算法.
回收步骤:

>初始标记: 会STW(stop the word),但是在多线程下时间很短.
并发标记: 开出一个线程进行慢慢标记.
最终标记:
筛选回收: 回收后会马上合并空闲空间.

### JVM性能检测工具
可视化: JVisualVM、MAT,Jconsole
命令: jmap,jstat,dump

####　**5.方法区(jdk1.7-) 元空间(jdk1.8+)**
方法区又称永久代:
存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

> 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。

元空间常用命令参数:
```
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```
==与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。==

#####　**5.1 运行时常量池**
* 存放: Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表.
除了==字符串常量池==被拿到了堆区,其余都在方法区(元空间).

## Java内存模型（JMM）
java 内存模型(JMM)是线程间通信的控制机制.JMM 定义了**主内存**和**线程**之间抽象关系。
线程之间的共享变量存储在 ==主内存（main memory）== 中，每个线程都有一个私有的本地内存（local memory），==本地内存中存储了该线程以读/写共享变量的副本==。本地内存是JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。


## 对象实例化过程
![](/img/images/Java创建对象的过程.png)
#### 1.类加载检查
虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在**常量池**中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
#### 2.分配内存
对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。
**分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。**
![](/img/images/内存分配的两种方式.png)
解决并发问题:

* CAS+失败重试:   保证更新操作的原子性。
* TLAB: 先在TLAB区分配,如果分配不下再CAS+重试.

#### 3.初始化零值
* **将分配到的内存空间都初始化为零值（不包括对象头）**.——把获得的内存清空，保证了安全性。

  ==实例变量==不用初始化也能使用的**原因**.

#### 4.设置对象头
虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄,是否启用偏向锁等信息。 

#### 5.执行init()方法
执行 <init> 方法，把对象按照程序员的意愿进行初始化,即把零值替换为真实值.



## 类的加载过程？

[Java类加载机制全套](<https://juejin.im/post/5a810b0e5188257a5c606a85#heading-2>)

![](/img/images/类加载过程.png)
>  (1) 装载：查找和导入Class文件(这个阶段可以自定义类加载器)；
  (2) 链接：把类的二进制数据合并到JRE中；
  ===(a)校验：检查载入Class文件数据的正确性；
  ===(b)准备：给类的静态变量分配存储空间；
  ===(c)解析：将符号引用转成直接引用；
  (3) 初始化：对类的**静态变量，静态代码块**执行初始化操作

static修饰的变量**在 ^准备阶段^ 赋值为初始值**，初始化阶段才赋值。
==static修饰局部变量（编译不过）==

#### 加载阶段
> 一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。
类加载器:
- 启动类加载器（Bootstrap ClassLoader）由c++实现
> 负责加载`%JAVA_HOME%/lib`目录中并且能被虚拟机识别的类库到JVM内存中，如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。
- 其他类加载器,由Java语言实现,都继承自java.lang.ClassLoader
  - 1. 扩展类加载器（ExtensionClassLoader）：该加载器主要是负责加载`%JRE_HOME%/lib/ext`，该加载器可以被开发者直接使用。
  - 2. 应用程序类加载器（ApplicationClassLoader）^默认的类加载器^：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库

#### 准备阶段
准备阶段是正式**为类变量分配内存**并**设置类变量初始值**的阶段，这些内存都将在**方法区**中分配。
- 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
- 这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。
==特殊情况:== 比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。

#### 解析阶段
解析阶段是虚拟机将**常量池内的符号引用替换为直接引用**的过程,得到类或者字段、方法在内存中的指针或者偏移量。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。
> 符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。



**==双亲委派机制==**
子加载器收到加载请求先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。
```
protected synchronized Class loadClass(String name, boolean resolve)  
        throws ClassNotFoundException {  
    // 首先检查该name指定的class是否有被加载  
    Class c = findLoadedClass(name);  
    if (c == null) {  
        try {  
            if (parent != null) {  
                // 如果parent不为null，则调用parent的loadClass进行加载  
                c = parent.loadClass(name, false);  
            } else {  
                // parent为null，则调用BootstrapClassLoader进行加载  
                c = findBootstrapClass0(name);  
            }  
        } catch (ClassNotFoundException e) {  
            // 如果仍然无法加载成功，则调用自身的findClass进行加载  
            c = findClass(name);  
        }  
    }  
    if (resolve) {  
        resolveClass(c);  
    }  
    return c;  
}  
```
## 对象的内存布局
包含三部分:
* **对象头**
  * 对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等）
  * 类型指针(对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例)

* **实例数据**
对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。

* 对齐填充
因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。

## 对象的访问定位
1.使用句柄
![](/img/images/对象访问-使用句柄.png)

2.直接指针
![](/img/images/对象的访问定位-直接指针.png)

***
## JVM调优常用参数：
|参数名称 |含义	|默认值	|说明|
|--|--|--|--|
-Xms	|初始堆大小	|物理内存的1/64(<1GB)	|默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.

-Xmx	|最大堆大小	|物理内存的1/4(<1GB)	|默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制
-Xmn	|年轻代大小(1.4or lator)	| |	注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8
-XX:NewSize	|设置年轻代大小(for 1.3/1.4)	| | |	
-XX:MaxNewSize	|年轻代最大值(for 1.3/1.4)		| | |
-XX:PermSize	|设置持久代(perm gen)初始值	| 物理内存的1/64	| |
-XX:MaxPermSize	设置持久代最大值	物理内存的1/4	
